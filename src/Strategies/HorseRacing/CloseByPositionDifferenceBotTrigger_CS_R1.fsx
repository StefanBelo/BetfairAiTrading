// Code generated by Claude Sonnet 4

module BfexplorerBot

#I @"C:\Program Files\BeloSoft\Bfexplorer\"

#r "BeloSoft.Data.dll"
#r "BeloSoft.Bfexplorer.Domain.dll"
#r "BeloSoft.Bfexplorer.Service.Core.dll"
#r "BeloSoft.Bfexplorer.Trading.dll"

open System
open System.ComponentModel.DataAnnotations

open BeloSoft.Bfexplorer.Domain
open BeloSoft.Bfexplorer.Trading

/// <summary>
/// SelectionPositionData - holds state for each selection being monitored
/// </summary>
type SelectionPositionData =
    {
        Selection : Selection
        InitialPosition : int
        CurrentPosition : int
        InitialOdds : float
        [<DisplayFormat (DataFormatString = "{0:n2}")>]
        CurrentOdds : float
        HasTriggered : bool
    }

    static member DataKey = "SelectionPositionData"

    [<DisplayFormat (DataFormatString = "{0:n0}")>]
    member this.PositionChange
        with get () = this.CurrentPosition - this.InitialPosition

    override this.ToString () = 
        sprintf "%s: Pos %d->%d (Î”%+d), Odds %.2f->%.2f, Triggered: %b" 
            this.Selection.Name 
            this.InitialPosition 
            this.CurrentPosition 
            this.PositionChange
            this.InitialOdds
            this.CurrentOdds
            this.HasTriggered

    interface ISelection with
        member this.GetSelection () = this.Selection

    static member Create (selection : Selection, position : int) =
        {
            Selection = selection
            InitialPosition = position
            CurrentPosition = position
            InitialOdds = selection.LastPriceTraded
            CurrentOdds = selection.LastPriceTraded
            HasTriggered = false
        }

    member this.UpdatePosition (newPosition : int, newOdds : float) =
        { this with 
            CurrentPosition = newPosition
            CurrentOdds = newOdds }

    member this.MarkAsTriggered () =
        { this with HasTriggered = true }

/// <summary>
/// TriggerStatus - state machine for the bot
/// </summary>
type TriggerStatus =
    | Initialize
    | Monitor
    | ClosePositions of Selection list
    | EndExecution

/// <summary>
/// CloseByPositionDifferenceBotTrigger
/// </summary>
type CloseByPositionDifferenceBotTrigger (market : Market, selection : Selection, botName : string, botTriggerParameters : BotTriggerParameters, myBfexplorer : IMyBfexplorer) =
    inherit BotTriggerBase (market, selection, botName, botTriggerParameters, myBfexplorer)

    let mutable triggerStatus = TriggerStatus.Initialize
    let mutable selectionPositionData = []

    // Configuration parameters
    let positionDifference = defaultArg (botTriggerParameters.GetParameter<int> "PositionDifference") 2
    let minimalFavouriteOdds = defaultArg (botTriggerParameters.GetParameter<float> "MinimalFavouriteOdds") 0.0
    let showPositionChanges = defaultArg (botTriggerParameters.GetParameter<bool> "ShowPositionChanges") false

    let isMyHorseRacingMarket () =
        market.MarketInfo.BetEventType.Id = 7 && market.MarketDescription.MarketType = "WIN"

    let getSelectionPosition (selection : Selection) (sortedSelections : Selection list) =
        sortedSelections 
        |> List.findIndex (fun s -> s.Identity.Id = selection.Identity.Id) 
        |> (+) 1  // Convert to 1-based position

    let getSortedSelectionsByOdds () =
        getActiveSelections market
        |> List.filter (fun s -> s.LastPriceTraded > 0.0)
        |> List.sortBy (fun s -> s.LastPriceTraded)

    let getFavouriteOdds () =
        let sortedSelections = getSortedSelectionsByOdds ()
        match sortedSelections with
        | favourite :: _ -> favourite.LastPriceTraded
        | [] -> Double.MaxValue

    let checkAllTriggered () =
        selectionPositionData |> List.forall (fun data -> data.HasTriggered)

    member this.InitializeSelectionData () =
        let sortedSelections = getSortedSelectionsByOdds ()
        let allActiveSelections = getActiveSelections market
        
        // Create SelectionPositionData for all active selections first
        let allSelectionData = 
            allActiveSelections
            |> List.map (fun sel -> 
                let position = getSelectionPosition sel sortedSelections
                SelectionPositionData.Create (sel, position))
        
        // Filter by selection criteria
        let monitoredSelectionData = this.GetMySelectionsBySelectionCriteria allSelectionData
        
        selectionPositionData <- monitoredSelectionData

        this.Report (sprintf "Initialized monitoring for %d selections with position difference threshold: %d" selectionPositionData.Length positionDifference)
        
        if showPositionChanges then
            this.Report "Initial positions:"
            selectionPositionData 
            |> List.iter (fun data -> this.Report (sprintf "  %s" (data.ToString())))

    member this.UpdatePositions () =
        let sortedSelections = getSortedSelectionsByOdds ()
        let mutable triggeredSelections = []

        selectionPositionData <-
            selectionPositionData
            |> List.map (fun data ->
                if not data.HasTriggered then
                    let newPosition = getSelectionPosition data.Selection sortedSelections
                    let newOdds = data.Selection.LastPriceTraded
                    let updatedData = data.UpdatePosition (newPosition, newOdds)
                    
                    if newPosition <> data.CurrentPosition && showPositionChanges then
                        this.Report (sprintf "%s position changed: %d -> %d (odds: %.2f -> %.2f)" 
                                   data.Selection.Name data.CurrentPosition newPosition data.CurrentOdds newOdds)
                    
                    // Check if position difference threshold is exceeded
                    if updatedData.PositionChange >= positionDifference then
                        let triggeredData = updatedData.MarkAsTriggered()
                        triggeredSelections <- data.Selection :: triggeredSelections
                        this.Report (sprintf "TRIGGER: %s dropped %d positions (threshold: %d) - marking for closure" 
                                   data.Selection.Name updatedData.PositionChange positionDifference)
                        triggeredData
                    else
                        updatedData
                else
                    data
            )

        // Check favourite odds trigger
        if minimalFavouriteOdds > 0.0 then
            let favouriteOdds = getFavouriteOdds ()
            if favouriteOdds <= minimalFavouriteOdds then
                this.Report (sprintf "TRIGGER: Favourite odds (%.2f) below threshold (%.2f) - closing all monitored positions" 
                           favouriteOdds minimalFavouriteOdds)
                let allUnTriggeredSelections = 
                    selectionPositionData 
                    |> List.filter (fun data -> not data.HasTriggered)
                    |> List.map (fun data -> data.Selection)
                
                selectionPositionData <-
                    selectionPositionData
                    |> List.map (fun data -> if not data.HasTriggered then data.MarkAsTriggered() else data)
                
                triggeredSelections <- allUnTriggeredSelections @ triggeredSelections

        triggeredSelections

    interface IBotTrigger with

        /// <summary>
        /// Execute
        /// </summary>
        member this.Execute () =
            match triggerStatus with
            | TriggerStatus.Initialize ->
                if isMyHorseRacingMarket () then
                    this.InitializeSelectionData ()
                    
                    if selectionPositionData.IsEmpty then
                        TriggerResult.EndExecutionWithMessage "No selections match the selection criteria for monitoring"
                    else
                        // Store data for potential use by action bots
                        market.SetData (SelectionPositionData.DataKey, selectionPositionData)
                        triggerStatus <- TriggerStatus.Monitor
                        TriggerResult.WaitingForOperation
                else
                    TriggerResult.EndExecutionWithMessage "You can run this bot on a horse racing WIN market only!"

            | TriggerStatus.Monitor ->
                let triggeredSelections = this.UpdatePositions ()
                
                if not triggeredSelections.IsEmpty then
                    triggerStatus <- TriggerStatus.ClosePositions triggeredSelections
                    // Update stored data
                    market.SetData (SelectionPositionData.DataKey, selectionPositionData)
                    TriggerResult.ExecuteActionBotOnSelectionsAndContinueToExecute (triggeredSelections, true)
                elif checkAllTriggered () then
                    this.Report "All monitored selections have been triggered - ending execution"
                    triggerStatus <- TriggerStatus.EndExecution
                    TriggerResult.EndExecution
                else
                    TriggerResult.WaitingForOperation

            | TriggerStatus.ClosePositions _ ->
                // Continue monitoring for remaining selections
                if checkAllTriggered () then
                    this.Report "All monitored selections have been processed - ending execution"
                    triggerStatus <- TriggerStatus.EndExecution
                    TriggerResult.EndExecution
                else
                    triggerStatus <- TriggerStatus.Monitor
                    TriggerResult.WaitingForOperation

            | TriggerStatus.EndExecution ->
                TriggerResult.EndExecution

        /// <summary>
        /// EndExecution
        /// </summary>
        member this.EndExecution () =
            if showPositionChanges && not selectionPositionData.IsEmpty then
                this.Report "Final position summary:"
                selectionPositionData 
                |> List.iter (fun data -> this.Report (sprintf "  %s" (data.ToString())))
