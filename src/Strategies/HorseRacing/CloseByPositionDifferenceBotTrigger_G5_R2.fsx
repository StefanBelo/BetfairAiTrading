// Code generated by GPT-5 (Preview) (R2 variant)
// Purpose: Close bet positions when a runner's favourite rank deteriorates by a configured number of places
//          OR when the (current) favourite trades below a configured odds threshold.
// Notes:
//  - Uses a simple two state finite state machine (Initialize -> Monitor)
//  - Tracks initial favourite indices at initialization and compares current ordering on each tick
//  - Removes selections once action executed for them; ends execution when nothing left to monitor
//  - Respects default config values when parameters not supplied
//  - MinimalFavouriteOdds is only applied when > 0.0 (0 disables the condition)

module BfexplorerBot

#I @"C:\Program Files\BeloSoft\Bfexplorer\"

#r "BeloSoft.Data.dll"
#r "BeloSoft.Bfexplorer.Domain.dll"
#r "BeloSoft.Bfexplorer.Trading.dll"
#r "BeloSoft.Bfexplorer.Service.Core.dll"

open System
open System.Collections.Generic

open BeloSoft.Data
open BeloSoft.Bfexplorer.Domain
open BeloSoft.Bfexplorer.Trading

/// Record holding per selection tracking data
type SelectionFavouriteData =
    {
        Selection : Selection
        InitialFavouriteIndex : int
        mutable CurrentFavouriteIndex : int
    }

    static member Create (selection : Selection, initialIndex : int) =
        { Selection = selection; InitialFavouriteIndex = initialIndex; CurrentFavouriteIndex = initialIndex }

    /// Build initial snapshot for all selections on which we could close a position
    static member CreateAll (market : Market) =
        let favourites = getFavouriteSelections market
        List (
            favourites
            |> List.mapi (fun i sel -> sel, i + 1)
            |> List.filter (fun (sel, _idx) -> sel.CanCloseBetPosition)
            |> Seq.map (fun (sel, idx) -> SelectionFavouriteData.Create (sel, idx))
        )

/// Simple state machine for the trigger
type TriggerStatus =
    | Initialize
    | Monitor

/// CloseByPositionDifferenceBotTrigger_GC_R2
type CloseByPositionDifferenceBotTrigger_GC_R2 (market : Market, selection : Selection, botName : string, botTriggerParameters : BotTriggerParameters, myBfexplorer : IMyBfexplorer) as this =
    inherit BotTriggerBase (market, selection, botName, botTriggerParameters, myBfexplorer)

    // Configurable parameters (with defaults)
    let positionDifference = defaultArg (botTriggerParameters.GetParameter<int> "PositionDifference") 2
    let minimalFavouriteOddsRaw = defaultArg (botTriggerParameters.GetParameter<float> "MinimalFavouriteOdds") 0.0
    let showPositionChanges = defaultArg (botTriggerParameters.GetParameter<bool> "ShowPositionChanges") false

    // Treat 0.0 (or negative) as disabled threshold
    let minimalFavouriteOdds = if minimalFavouriteOddsRaw > 0.0 then minimalFavouriteOddsRaw else Double.NaN

    let mutable status = TriggerStatus.Initialize
    let mutable watchedSelections = nil<List<SelectionFavouriteData>>

    // Validation: only allow Horse Racing WIN markets (BetEventType.Id = 7, MarketType = "WIN")
    let isHorseRacingWin () =
        market.MarketInfo.BetEventType.Id = 7 && market.MarketDescription.MarketType = "WIN"

    let initialize () =
        let initial = SelectionFavouriteData.CreateAll market
        watchedSelections <- initial
        watchedSelections.Count > 0

    let remove (data : SelectionFavouriteData) =
        watchedSelections.Remove data |> ignore

    /// Attempt to map a tracked selection to its current favourite index. Returns None if selection disappeared.
    let tryGetCurrentFavouriteIndex (selData : SelectionFavouriteData) (favourites : Selection list) =
        let id = selData.Selection.Identity
        favourites
        |> List.tryFindIndex (fun (s : Selection) -> s.Identity = id)
        |> Option.map ((+) 1)

    let evaluate () =
        if watchedSelections.Count = 0 then
            None
        else
            let favourites = getFavouriteSelections market
            match favourites with
            | [] -> None // Market data not available – end
            | favHead :: _ ->
                let favouriteOdds = favHead.LastPriceTraded
                let mutable toExecute = List.empty<SelectionFavouriteData>

                for sd in watchedSelections do
                    match tryGetCurrentFavouriteIndex sd favourites with
                    | None ->
                        // Selection no longer in ordering (removed / withdrawn) – stop watching
                        remove sd
                    | Some currentIdx ->
                        let delta = currentIdx - sd.InitialFavouriteIndex
                        if showPositionChanges && currentIdx <> sd.CurrentFavouriteIndex then
                            sd.CurrentFavouriteIndex <- currentIdx
                            this.Report ($"{currentIdx}. {sd.Selection} | Δ={delta}")

                        let favouriteCondition = not (Double.IsNaN minimalFavouriteOdds) && favouriteOdds <= minimalFavouriteOdds
                        let positionCondition = delta >= positionDifference

                        if favouriteCondition || positionCondition then
                            toExecute <- sd :: toExecute

                // Remove executed selections from watch list
                toExecute |> List.iter remove

                if toExecute.IsEmpty then
                    Some [] // Continue waiting
                else
                    toExecute
                    |> List.map (fun sd -> sd.Selection)
                    |> Some

    interface IBotTrigger with

        member _this.Execute () =
            match status with
            | TriggerStatus.Initialize ->
                if isHorseRacingWin () then
                    if initialize () then
                        status <- TriggerStatus.Monitor
                        TriggerResult.WaitingForOperation
                    else
                        TriggerResult.EndExecution
                else
                    TriggerResult.EndExecutionWithMessage "You can execute this bot only on a horse racing WIN market!"

            | TriggerStatus.Monitor ->
                match evaluate () with
                | None -> TriggerResult.EndExecution
                | Some selectionsToClose ->
                    if selectionsToClose.IsEmpty then
                        // Still monitoring remaining selections
                        if watchedSelections.Count = 0 then
                            TriggerResult.EndExecution
                        else
                            TriggerResult.WaitingForOperation
                    else
                        TriggerResult.ExecuteActionBotOnSelectionsAndContinueToExecute (selectionsToClose, true)

        member _this.EndExecution () = ()
