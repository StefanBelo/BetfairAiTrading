// Code generated by Grok Code Fast 1

module BfexplorerBot

#I @"C:\Program Files\BeloSoft\Bfexplorer\"

#r "BeloSoft.Data.dll"
#r "BeloSoft.Bfexplorer.Domain.dll"
#r "BeloSoft.Bfexplorer.Service.Core.dll"
#r "BeloSoft.Bfexplorer.Trading.dll"

open System
open BeloSoft.Bfexplorer.Domain
open BeloSoft.Bfexplorer.Trading

/// <summary>
/// SelectionState
/// </summary>
type SelectionState =
    {
        SelectionId: int64
        SelectionName: string
        PreviousPosition: int
        CurrentPosition: int
    }

/// <summary>
/// TriggerStatus
/// </summary>
type TriggerStatus =
    | Initialize
    | Monitor

/// <summary>
/// CloseByPositionDifferenceBotTrigger
/// </summary>
type CloseByPositionDifferenceBotTrigger (market : Market, selection : Selection, botName : string, botTriggerParameters : BotTriggerParameters, myBfexplorer : IMyBfexplorer) =
    inherit BotTriggerBase (market, selection, botName, botTriggerParameters, myBfexplorer)

    let positionDifference = defaultArg (botTriggerParameters.GetParameter<int> "PositionDifference") 2
    let minimalFavouriteOdds = defaultArg (botTriggerParameters.GetParameter<float> "MinimalFavouriteOdds") 0.0
    let showPositionChanges = defaultArg (botTriggerParameters.GetParameter<bool> "ShowPositionChanges") false

    let mutable selectionStates = Map.empty<int64, SelectionState>
    let mutable triggerStatus = TriggerStatus.Initialize
    let mutable lastUpdateTime = DateTime.MinValue

    let isHorseRacingWinMarket () =
        market.MarketInfo.BetEventType.Id = 7 && market.MarketDescription.MarketType = "WIN"

    let getSelectionsSortedByOdds () =
        market.Selections
        |> Seq.filter (fun s -> s.Status = SelectionStatus.Active)
        |> Seq.sortBy (fun s -> s.LastPriceTraded)
        |> Seq.toList

    let getSelectionPosition (selectionId: int64) (sortedSelections: Selection list) =
        sortedSelections
        |> List.findIndex (fun s -> s.Identity.Id = selectionId)
        |> (+) 1 // Positions are 1-based

    member private this.UpdateSelectionStates () =
        let sortedSelections = getSelectionsSortedByOdds()

        let newStates =
            sortedSelections
            |> List.map (fun s ->
                let selectionId = s.Identity.Id
                let currentPosition = getSelectionPosition selectionId sortedSelections

                match selectionStates.TryFind selectionId with
                | Some existingState ->
                    let updatedState = { existingState with CurrentPosition = currentPosition }
                    if showPositionChanges && existingState.PreviousPosition <> currentPosition then
                        this.Report (sprintf "Horse %s position changed from %d to %d" s.Name existingState.PreviousPosition currentPosition)
                    updatedState
                | None ->
                    {
                        SelectionId = selectionId
                        SelectionName = s.Name
                        PreviousPosition = currentPosition
                        CurrentPosition = currentPosition
                    }
            )
            |> List.map (fun state -> state.SelectionId, state)
            |> Map.ofList

        selectionStates <- newStates

    member private this.GetSelectionsToClose () =
        let sortedSelections = getSelectionsSortedByOdds()
        let favourite = sortedSelections |> List.tryHead

        let favouriteOddsTooLow =
            match favourite with
            | Some fav when minimalFavouriteOdds > 0.0 && fav.LastPriceTraded < minimalFavouriteOdds -> true
            | _ -> false

        if favouriteOddsTooLow then
            this.Report (sprintf "Favourite odds (%.2f) below threshold (%.2f), closing all positions" favourite.Value.LastPriceTraded minimalFavouriteOdds)
            sortedSelections |> List.filter (fun s -> s.CanCloseBetPosition)
        else
            selectionStates
            |> Map.toList
            |> List.map snd
            |> List.filter (fun state ->
                let positionDrop = state.CurrentPosition - state.PreviousPosition
                positionDrop >= positionDifference
            )
            |> List.choose (fun state ->
                market.Selections |> Seq.tryFind (fun s -> s.Identity.Id = state.SelectionId && s.CanCloseBetPosition)
            )

    member private this.Initialize () =
        this.UpdateSelectionStates()
        this.Report (sprintf "Initialized with %d active selections" selectionStates.Count)

    interface IBotTrigger with

        /// <summary>
        /// Execute
        /// </summary>
        member this.Execute () =
            if not (isHorseRacingWinMarket ()) then
                TriggerResult.EndExecutionWithMessage "You can run this bot on a horse racing WIN market only!"
            else
                match triggerStatus with
                | TriggerStatus.Initialize ->
                    this.Initialize ()
                    triggerStatus <- TriggerStatus.Monitor
                    lastUpdateTime <- DateTime.Now
                    TriggerResult.WaitingForOperation

                | TriggerStatus.Monitor ->
                    let timeSinceLastUpdate = DateTime.Now - lastUpdateTime
                    if timeSinceLastUpdate.TotalSeconds >= 1.0 then
                        this.UpdateSelectionStates()
                        lastUpdateTime <- DateTime.Now

                        let selectionsToClose = this.GetSelectionsToClose()
                        if not selectionsToClose.IsEmpty then
                            this.Report (sprintf "Closing bets on %d selections due to position changes" selectionsToClose.Length)
                            TriggerResult.ExecuteActionBotOnSelectionsAndContinueToExecute (selectionsToClose, true)
                        else
                            TriggerResult.WaitingForOperation
                    else
                        TriggerResult.WaitingForOperation

        /// <summary>
        /// EndExecution
        /// </summary>
        member this.EndExecution () =
            this.Report "Bot execution ended"
