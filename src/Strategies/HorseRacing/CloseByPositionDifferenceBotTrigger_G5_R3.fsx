// Code generated by GPT-5 (Preview)

// Variant: G5_R3
// Rationale: Unified refined implementation combining rich state tracking (inspired by Claude variants)
// with concise production style (Grok Code R1) and explicit favourite odds global closure rule.
// Adds light validation, stable ranking, and optional verbose logging.

module BfexplorerBot

#I @"C:\Program Files\BeloSoft\Bfexplorer\"

#r "BeloSoft.Data.dll"
#r "BeloSoft.Bfexplorer.Domain.dll"
#r "BeloSoft.Bfexplorer.Trading.dll"
#r "BeloSoft.Bfexplorer.Service.Core.dll"

open System
open BeloSoft.Bfexplorer.Domain
open BeloSoft.Bfexplorer.Trading

/// SelectionPositionData - tracks initial & current ranking plus odds evolution and trigger status
[<CLIMutable>]
type SelectionPositionData = {
    Selection : Selection
    InitialRank : int
    mutable CurrentRank : int
    InitialOdds : float
    mutable LastOdds : float
    mutable Triggered : bool
    mutable LastLoggedRank : int
}
with
    override this.ToString () =
        sprintf "%s | initRank=%d currRank=%d Δ=%+d initOdds=%.2f lastOdds=%.2f%s" 
            this.Selection.Name this.InitialRank this.CurrentRank (this.CurrentRank - this.InitialRank) 
            this.InitialOdds this.LastOdds (if this.Triggered then " [TRIGGERED]" else "")

    interface ISelection with
        member this.GetSelection () = this.Selection

/// TriggerStatus state machine
[<Struct>]
type TriggerStatus =
    | Initialize
    | Monitor
    | Closing

/// Helpers
let private isHorseRacingWinMarket (market : Market) =
    market.MarketInfo.BetEventType.Id = 7 && market.MarketDescription.MarketType = "WIN"

let private getActiveSelectionsSortedByOdds (market : Market) =
    // Stable ordering: sort by LastPriceTraded then by Selection Identity Id to break ties
    getActiveSelections market
    |> List.sortBy (fun s -> s.LastPriceTraded, s.Identity.Id)

let private getFavourite (market : Market) =
    getActiveSelectionsSortedByOdds market |> List.tryHead

let private buildInitialState (market : Market) =
    getActiveSelectionsSortedByOdds market
    |> List.mapi (fun idx sel ->
        { Selection = sel; InitialRank = idx + 1; CurrentRank = idx + 1; InitialOdds = sel.LastPriceTraded; LastOdds = sel.LastPriceTraded; Triggered = false; LastLoggedRank = idx + 1 })

/// Bot Trigger Implementation
/// CloseByPositionDifferenceBotTrigger_G5_R3
/// Parameters:
///  PositionDifference (int, default 2)
///  MinimalFavouriteOdds (float, default 0.0 => disabled when <= 0.0)
///  ShowPositionChanges (bool, default false)
type CloseByPositionDifferenceBotTrigger_G5_R3 (market : Market, selection : Selection, botName : string, botTriggerParameters : BotTriggerParameters, myBfexplorer : IMyBfexplorer) =
    inherit BotTriggerBase (market, selection, botName, botTriggerParameters, myBfexplorer)

    // Mutable state
    let mutable status = TriggerStatus.Initialize
    let mutable selectionsData : SelectionPositionData list = []

    // Parameters
    let positionDifference =
        defaultArg (botTriggerParameters.GetParameter<int> "PositionDifference") 2
        |> max 1 // enforce >= 1
    let minimalFavouriteOdds =
        defaultArg (botTriggerParameters.GetParameter<float> "MinimalFavouriteOdds") 0.0
    let showPositionChanges =
        defaultArg (botTriggerParameters.GetParameter<bool> "ShowPositionChanges") false

    let log (this : BotTriggerBase) (msg : string) =
        this.Report msg

    let recomputeRanksAndDetectChanges (this : BotTriggerBase) =
        let ranked = getActiveSelectionsSortedByOdds market
        // Build lookup for rank
        let rankMap = ranked |> List.mapi (fun i s -> s.Identity.Id, i + 1) |> dict
        for spd in selectionsData do
            if not spd.Triggered && rankMap.ContainsKey spd.Selection.Identity.Id then
                let newRank = rankMap.[spd.Selection.Identity.Id]
                if newRank <> spd.CurrentRank then
                    spd.CurrentRank <- newRank
                    // Odds update
                    spd.LastOdds <- spd.Selection.LastPriceTraded
                    if showPositionChanges then
                        log this (sprintf "PosChange: %s %d -> %d Δ=%+d" spd.Selection.Name spd.LastLoggedRank newRank (newRank - spd.LastLoggedRank))
                    spd.LastLoggedRank <- newRank
            else
                // Selection no longer active; mark as triggered (treat as closed)
                spd.Triggered <- true

    let evaluateTriggers (this : BotTriggerBase) =
        // Favourite rule first
        let favouriteOddsTriggered =
            if minimalFavouriteOdds > 0.0 then
                match getFavourite market with
                | Some fav when fav.LastPriceTraded > 1.0 && fav.LastPriceTraded <= minimalFavouriteOdds -> true
                | _ -> false
            else false

        if favouriteOddsTriggered then
            // Mark all not yet triggered to trigger
            selectionsData |> List.iter (fun s -> if not s.Triggered then s.Triggered <- true)
            log this (sprintf "Favourite odds rule met (<= %.2f). Closing all monitored selections." minimalFavouriteOdds)
        else
            // Rank difference rule
            for spd in selectionsData do
                if not spd.Triggered then
                    let diff = spd.CurrentRank - spd.InitialRank
                    if diff >= positionDifference then
                        spd.Triggered <- true
                        if showPositionChanges then
                            log this (sprintf "Triggered: %s ΔRank=%d (initial %d -> %d)" spd.Selection.Name diff spd.InitialRank spd.CurrentRank)

    let getTriggeredUnexecutedSelections () =
        selectionsData |> List.filter (fun s -> s.Triggered)

    interface IBotTrigger with
        member this.Execute () =
            match status with
            | TriggerStatus.Initialize ->
                if not (isHorseRacingWinMarket market) then
                    TriggerResult.EndExecutionWithMessage "This bot can run only on Horse Racing WIN markets."
                else
                    selectionsData <- buildInitialState market
                    if selectionsData.IsEmpty then
                        TriggerResult.EndExecutionWithMessage "No active selections to monitor."
                    else
                        status <- TriggerStatus.Monitor
                        if showPositionChanges then
                            log this (sprintf "Monitoring %d selections. PositionDifference=%d MinimalFavouriteOdds=%.2f" selectionsData.Length positionDifference minimalFavouriteOdds)
                        TriggerResult.WaitingForOperation

            | TriggerStatus.Monitor ->
                recomputeRanksAndDetectChanges this
                evaluateTriggers this

                let toClose =
                    getTriggeredUnexecutedSelections ()
                    |> List.choose (fun s -> if s.Selection.Status = SelectionStatus.Active then Some s.Selection else None)

                if toClose.IsEmpty then
                    // Continue monitoring
                    TriggerResult.WaitingForOperation
                else
                    // Remove those already closed from further consideration by keeping Triggered flag; continue monitoring others not yet triggered
                    let remainingActive = selectionsData |> List.exists (fun s -> not s.Triggered)
                    TriggerResult.ExecuteActionBotOnSelectionsAndContinueToExecute (toClose, remainingActive)

            | TriggerStatus.Closing ->
                // Not used in this streamlined variant; end.
                TriggerResult.EndExecution

        member this.EndExecution () =
            if showPositionChanges && not selectionsData.IsEmpty then
                let summary =
                    selectionsData
                    |> List.map (fun s -> s.ToString ())
                    |> String.concat Environment.NewLine
                try (this :> BotTriggerBase).Report ("Summary:\n" + summary) with _ -> ()
            ()
